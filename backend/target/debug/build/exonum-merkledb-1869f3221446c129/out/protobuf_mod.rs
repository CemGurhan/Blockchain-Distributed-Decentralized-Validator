pub mod map_proof ; pub mod list_proof ; # [doc = r" Original proto files which were be used to generate this module."] # [doc = r" First element in tuple is file name, second is proto file content."] # [allow (dead_code)] # [allow (clippy :: unseparated_literal_suffix)] pub const PROTO_SOURCES : [(& str , & str) ; 2usize] = [("exonum/proof/map_proof.proto" , "// Copyright 2020 The Exonum Team\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\nimport \"exonum/crypto/types.proto\";\nimport \"google/protobuf/empty.proto\";\n\npackage exonum.proof;\n\noption java_package = \"com.exonum.messages.proof\";\n\n// Subset of map elements coupled with a proof. MapProof can assert existence/absence of certain keys\n// from the underlying map.\nmessage MapProof {\n  // Array with 2 kinds of objects: `{ key, no_value }` for keys missing from\n  // the underlying index, and `{ key, value }` for key-value pairs, existence of\n  // which is asserted by the proof.\n  repeated OptionalEntry entries = 1;\n  // Array of { path: ProofPath, hash: Hash } objects.\n  repeated MapProofEntry proof = 2;\n}\n\n// Key with corresponding value or an empty value if the key is missing\n// from the underlying map.\nmessage OptionalEntry {\n  // Key serialized as per `BinaryValue` implementation (usually as\n  // a Protobuf message, except for primitive types).\n  bytes key = 1;\n  oneof maybe_value {\n    // Value serialized per `BinaryValue` implementation (usually as\n    // a Protobuf message, except for primitive types).\n    bytes value = 2;\n    // Indicator that `key` is missing from the underlying map.\n    google.protobuf.Empty no_value = 3;\n  }\n}\n\n// Path to an intermediate Merkle Patricia tree node and a corresponding\n// hash value.\nmessage MapProofEntry {\n  // Path to the node, expressed with the minimum necessary number of bytes.\n  // Bits within each byte are indexed from the least significant to\n  // the most significant.\n  // The last byte may be padded with zeros if necessary.\n  bytes path = 1;\n  // Hash associated with the node.\n  exonum.crypto.Hash hash = 2;\n  // Number of zero bit padding at the end of the path. Must be in the `0..8`\n  // interval.\n  uint32 path_padding = 3;\n}\n") , ("exonum/proof/list_proof.proto" , "// Copyright 2020 The Exonum Team\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\nimport \"exonum/crypto/types.proto\";\n\npackage exonum.proof;\n\noption java_package = \"com.exonum.messages.proof\";\n\n// Subset of ProofList elements coupled with a proof. ListProof` can assert existence of\n// certain elements and that the list is shorter than the requested range of indexes.\nmessage ListProof {\n  // Array of { ProofListKey, Hash } objects.\n  repeated HashedEntry proof = 1;\n  // Array with list elements and their indexes.\n  repeated ListProofEntry entries = 2;\n  // Length of the underlying `ProofListIndex`.\n  uint64 length = 3;\n}\n\n// Represents list key and corresponding hash value.\nmessage HashedEntry {\n  // Location of the node within the Merkle tree.\n  ProofListKey key = 1;\n  // Hash associated with the node.\n  exonum.crypto.Hash hash = 2;\n}\n\n// Index of the list element and its value.\nmessage ListProofEntry {\n  // Zero-based index of the element.\n  uint64 index = 1;\n  // Value serialized per `BinaryValue` implementation (usually as\n  // a Protobuf message, except for primitive types).\n  bytes value = 2;\n}\n\n// Node position in the Merkle tree.\nmessage ProofListKey {\n  // Zero-based index of the node on the level.\n  uint64 index = 1;\n  // Height of the element. Should always be greater than 0.\n  // 1 corresponds to the hashes of single elements, 2 to hashes\n  // obtained by hashing together pairs of hashes at height 1, etc.\n  uint32 height = 2;\n}\n") ,] ; # [doc = r" Original proto files which were be used to generate this module."] # [doc = r" First element in tuple is file name, second is proto file content."] # [allow (dead_code)] # [allow (clippy :: unseparated_literal_suffix)] pub const INCLUDES : [(& str , & str) ; 1usize] = [("exonum/crypto/types.proto" , "// Copyright 2020 The Exonum Team\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = \"proto3\";\n\npackage exonum.crypto;\n\noption java_package = \"com.exonum.messages.crypto\";\n\nmessage Hash { bytes data = 1; }\n\nmessage PublicKey { bytes data = 1; }\n\nmessage Signature { bytes data = 1; }\n") ,] ;