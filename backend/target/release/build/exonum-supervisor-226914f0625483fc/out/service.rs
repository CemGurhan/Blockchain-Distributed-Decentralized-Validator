// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeployRequest {
    // message fields
    pub artifact: ::protobuf::SingularPtrField<super::base::ArtifactId>,
    pub spec: ::std::vec::Vec<u8>,
    pub deadline_height: u64,
    pub seed: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployRequest {
    fn default() -> &'a DeployRequest {
        <DeployRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeployRequest {
    pub fn new() -> DeployRequest {
        ::std::default::Default::default()
    }

    // .exonum.runtime.ArtifactId artifact = 1;


    pub fn get_artifact(&self) -> &super::base::ArtifactId {
        self.artifact.as_ref().unwrap_or_else(|| <super::base::ArtifactId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_artifact(&mut self) {
        self.artifact.clear();
    }

    pub fn has_artifact(&self) -> bool {
        self.artifact.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artifact(&mut self, v: super::base::ArtifactId) {
        self.artifact = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artifact(&mut self) -> &mut super::base::ArtifactId {
        if self.artifact.is_none() {
            self.artifact.set_default();
        }
        self.artifact.as_mut().unwrap()
    }

    // Take field
    pub fn take_artifact(&mut self) -> super::base::ArtifactId {
        self.artifact.take().unwrap_or_else(|| super::base::ArtifactId::new())
    }

    // bytes spec = 2;


    pub fn get_spec(&self) -> &[u8] {
        &self.spec
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ::std::vec::Vec<u8>) {
        self.spec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.spec
    }

    // Take field
    pub fn take_spec(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.spec, ::std::vec::Vec::new())
    }

    // uint64 deadline_height = 3;


    pub fn get_deadline_height(&self) -> u64 {
        self.deadline_height
    }
    pub fn clear_deadline_height(&mut self) {
        self.deadline_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadline_height(&mut self, v: u64) {
        self.deadline_height = v;
    }

    // uint64 seed = 4;


    pub fn get_seed(&self) -> u64 {
        self.seed
    }
    pub fn clear_seed(&mut self) {
        self.seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: u64) {
        self.seed = v;
    }
}

impl ::protobuf::Message for DeployRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.artifact {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artifact)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deadline_height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.artifact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.spec.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.spec);
        }
        if self.deadline_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.deadline_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seed != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seed, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.artifact.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.spec.is_empty() {
            os.write_bytes(2, &self.spec)?;
        }
        if self.deadline_height != 0 {
            os.write_uint64(3, self.deadline_height)?;
        }
        if self.seed != 0 {
            os.write_uint64(4, self.seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployRequest {
        DeployRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::ArtifactId>>(
                "artifact",
                |m: &DeployRequest| { &m.artifact },
                |m: &mut DeployRequest| { &mut m.artifact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spec",
                |m: &DeployRequest| { &m.spec },
                |m: &mut DeployRequest| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "deadline_height",
                |m: &DeployRequest| { &m.deadline_height },
                |m: &mut DeployRequest| { &mut m.deadline_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seed",
                |m: &DeployRequest| { &m.seed },
                |m: &mut DeployRequest| { &mut m.seed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeployRequest>(
                "DeployRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeployRequest {
        static instance: ::protobuf::rt::LazyV2<DeployRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeployRequest::new)
    }
}

impl ::protobuf::Clear for DeployRequest {
    fn clear(&mut self) {
        self.artifact.clear();
        self.spec.clear();
        self.deadline_height = 0;
        self.seed = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeployResult {
    // message fields
    pub request: ::protobuf::SingularPtrField<DeployRequest>,
    pub result: ::protobuf::SingularPtrField<super::errors::ExecutionStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployResult {
    fn default() -> &'a DeployResult {
        <DeployResult as ::protobuf::Message>::default_instance()
    }
}

impl DeployResult {
    pub fn new() -> DeployResult {
        ::std::default::Default::default()
    }

    // .exonum.supervisor.DeployRequest request = 1;


    pub fn get_request(&self) -> &DeployRequest {
        self.request.as_ref().unwrap_or_else(|| <DeployRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: DeployRequest) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut DeployRequest {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> DeployRequest {
        self.request.take().unwrap_or_else(|| DeployRequest::new())
    }

    // .exonum.runtime.ExecutionStatus result = 2;


    pub fn get_result(&self) -> &super::errors::ExecutionStatus {
        self.result.as_ref().unwrap_or_else(|| <super::errors::ExecutionStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::errors::ExecutionStatus) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut super::errors::ExecutionStatus {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> super::errors::ExecutionStatus {
        self.result.take().unwrap_or_else(|| super::errors::ExecutionStatus::new())
    }
}

impl ::protobuf::Message for DeployResult {
    fn is_initialized(&self) -> bool {
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployResult {
        DeployResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeployRequest>>(
                "request",
                |m: &DeployResult| { &m.request },
                |m: &mut DeployResult| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::errors::ExecutionStatus>>(
                "result",
                |m: &DeployResult| { &m.result },
                |m: &mut DeployResult| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeployResult>(
                "DeployResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeployResult {
        static instance: ::protobuf::rt::LazyV2<DeployResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeployResult::new)
    }
}

impl ::protobuf::Clear for DeployResult {
    fn clear(&mut self) {
        self.request.clear();
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StartService {
    // message fields
    pub artifact: ::protobuf::SingularPtrField<super::base::ArtifactId>,
    pub name: ::std::string::String,
    pub config: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartService {
    fn default() -> &'a StartService {
        <StartService as ::protobuf::Message>::default_instance()
    }
}

impl StartService {
    pub fn new() -> StartService {
        ::std::default::Default::default()
    }

    // .exonum.runtime.ArtifactId artifact = 1;


    pub fn get_artifact(&self) -> &super::base::ArtifactId {
        self.artifact.as_ref().unwrap_or_else(|| <super::base::ArtifactId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_artifact(&mut self) {
        self.artifact.clear();
    }

    pub fn has_artifact(&self) -> bool {
        self.artifact.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artifact(&mut self, v: super::base::ArtifactId) {
        self.artifact = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artifact(&mut self) -> &mut super::base::ArtifactId {
        if self.artifact.is_none() {
            self.artifact.set_default();
        }
        self.artifact.as_mut().unwrap()
    }

    // Take field
    pub fn take_artifact(&mut self) -> super::base::ArtifactId {
        self.artifact.take().unwrap_or_else(|| super::base::ArtifactId::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bytes config = 3;


    pub fn get_config(&self) -> &[u8] {
        &self.config
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StartService {
    fn is_initialized(&self) -> bool {
        for v in &self.artifact {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artifact)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.artifact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.config);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.artifact.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.config.is_empty() {
            os.write_bytes(3, &self.config)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartService {
        StartService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::ArtifactId>>(
                "artifact",
                |m: &StartService| { &m.artifact },
                |m: &mut StartService| { &mut m.artifact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StartService| { &m.name },
                |m: &mut StartService| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "config",
                |m: &StartService| { &m.config },
                |m: &mut StartService| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartService>(
                "StartService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartService {
        static instance: ::protobuf::rt::LazyV2<StartService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartService::new)
    }
}

impl ::protobuf::Clear for StartService {
    fn clear(&mut self) {
        self.artifact.clear();
        self.name.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StopService {
    // message fields
    pub instance_id: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopService {
    fn default() -> &'a StopService {
        <StopService as ::protobuf::Message>::default_instance()
    }
}

impl StopService {
    pub fn new() -> StopService {
        ::std::default::Default::default()
    }

    // uint32 instance_id = 1;


    pub fn get_instance_id(&self) -> u32 {
        self.instance_id
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = v;
    }
}

impl ::protobuf::Message for StopService {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instance_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.instance_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.instance_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.instance_id != 0 {
            os.write_uint32(1, self.instance_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopService {
        StopService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "instance_id",
                |m: &StopService| { &m.instance_id },
                |m: &mut StopService| { &mut m.instance_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopService>(
                "StopService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopService {
        static instance: ::protobuf::rt::LazyV2<StopService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopService::new)
    }
}

impl ::protobuf::Clear for StopService {
    fn clear(&mut self) {
        self.instance_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FreezeService {
    // message fields
    pub instance_id: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FreezeService {
    fn default() -> &'a FreezeService {
        <FreezeService as ::protobuf::Message>::default_instance()
    }
}

impl FreezeService {
    pub fn new() -> FreezeService {
        ::std::default::Default::default()
    }

    // uint32 instance_id = 1;


    pub fn get_instance_id(&self) -> u32 {
        self.instance_id
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = v;
    }
}

impl ::protobuf::Message for FreezeService {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instance_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.instance_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.instance_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.instance_id != 0 {
            os.write_uint32(1, self.instance_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FreezeService {
        FreezeService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "instance_id",
                |m: &FreezeService| { &m.instance_id },
                |m: &mut FreezeService| { &mut m.instance_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FreezeService>(
                "FreezeService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FreezeService {
        static instance: ::protobuf::rt::LazyV2<FreezeService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FreezeService::new)
    }
}

impl ::protobuf::Clear for FreezeService {
    fn clear(&mut self) {
        self.instance_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FreezeService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FreezeService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServiceConfig {
    // message fields
    pub instance_id: u32,
    pub params: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceConfig {
    fn default() -> &'a ServiceConfig {
        <ServiceConfig as ::protobuf::Message>::default_instance()
    }
}

impl ServiceConfig {
    pub fn new() -> ServiceConfig {
        ::std::default::Default::default()
    }

    // uint32 instance_id = 1;


    pub fn get_instance_id(&self) -> u32 {
        self.instance_id
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = v;
    }

    // bytes params = 2;


    pub fn get_params(&self) -> &[u8] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::vec::Vec<u8>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.params, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ServiceConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instance_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.instance_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.instance_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.params.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.params);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.instance_id != 0 {
            os.write_uint32(1, self.instance_id)?;
        }
        if !self.params.is_empty() {
            os.write_bytes(2, &self.params)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceConfig {
        ServiceConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "instance_id",
                |m: &ServiceConfig| { &m.instance_id },
                |m: &mut ServiceConfig| { &mut m.instance_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "params",
                |m: &ServiceConfig| { &m.params },
                |m: &mut ServiceConfig| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceConfig>(
                "ServiceConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceConfig {
        static instance: ::protobuf::rt::LazyV2<ServiceConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceConfig::new)
    }
}

impl ::protobuf::Clear for ServiceConfig {
    fn clear(&mut self) {
        self.instance_id = 0;
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResumeService {
    // message fields
    pub instance_id: u32,
    pub params: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResumeService {
    fn default() -> &'a ResumeService {
        <ResumeService as ::protobuf::Message>::default_instance()
    }
}

impl ResumeService {
    pub fn new() -> ResumeService {
        ::std::default::Default::default()
    }

    // uint32 instance_id = 1;


    pub fn get_instance_id(&self) -> u32 {
        self.instance_id
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = v;
    }

    // bytes params = 3;


    pub fn get_params(&self) -> &[u8] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::vec::Vec<u8>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.params, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ResumeService {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instance_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.instance_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.instance_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.params.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.params);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.instance_id != 0 {
            os.write_uint32(1, self.instance_id)?;
        }
        if !self.params.is_empty() {
            os.write_bytes(3, &self.params)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResumeService {
        ResumeService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "instance_id",
                |m: &ResumeService| { &m.instance_id },
                |m: &mut ResumeService| { &mut m.instance_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "params",
                |m: &ResumeService| { &m.params },
                |m: &mut ResumeService| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResumeService>(
                "ResumeService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResumeService {
        static instance: ::protobuf::rt::LazyV2<ResumeService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResumeService::new)
    }
}

impl ::protobuf::Clear for ResumeService {
    fn clear(&mut self) {
        self.instance_id = 0;
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResumeService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UnloadArtifact {
    // message fields
    pub artifact_id: ::protobuf::SingularPtrField<super::base::ArtifactId>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnloadArtifact {
    fn default() -> &'a UnloadArtifact {
        <UnloadArtifact as ::protobuf::Message>::default_instance()
    }
}

impl UnloadArtifact {
    pub fn new() -> UnloadArtifact {
        ::std::default::Default::default()
    }

    // .exonum.runtime.ArtifactId artifact_id = 1;


    pub fn get_artifact_id(&self) -> &super::base::ArtifactId {
        self.artifact_id.as_ref().unwrap_or_else(|| <super::base::ArtifactId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_artifact_id(&mut self) {
        self.artifact_id.clear();
    }

    pub fn has_artifact_id(&self) -> bool {
        self.artifact_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artifact_id(&mut self, v: super::base::ArtifactId) {
        self.artifact_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artifact_id(&mut self) -> &mut super::base::ArtifactId {
        if self.artifact_id.is_none() {
            self.artifact_id.set_default();
        }
        self.artifact_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_artifact_id(&mut self) -> super::base::ArtifactId {
        self.artifact_id.take().unwrap_or_else(|| super::base::ArtifactId::new())
    }
}

impl ::protobuf::Message for UnloadArtifact {
    fn is_initialized(&self) -> bool {
        for v in &self.artifact_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artifact_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.artifact_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.artifact_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnloadArtifact {
        UnloadArtifact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::ArtifactId>>(
                "artifact_id",
                |m: &UnloadArtifact| { &m.artifact_id },
                |m: &mut UnloadArtifact| { &mut m.artifact_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnloadArtifact>(
                "UnloadArtifact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnloadArtifact {
        static instance: ::protobuf::rt::LazyV2<UnloadArtifact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnloadArtifact::new)
    }
}

impl ::protobuf::Clear for UnloadArtifact {
    fn clear(&mut self) {
        self.artifact_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnloadArtifact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnloadArtifact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConfigChange {
    // message oneof groups
    pub kind: ::std::option::Option<ConfigChange_oneof_kind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigChange {
    fn default() -> &'a ConfigChange {
        <ConfigChange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConfigChange_oneof_kind {
    consensus(super::blockchain::Config),
    service(ServiceConfig),
    start_service(StartService),
    stop_service(StopService),
    resume_service(ResumeService),
    freeze_service(FreezeService),
    unload_artifact(UnloadArtifact),
}

impl ConfigChange {
    pub fn new() -> ConfigChange {
        ::std::default::Default::default()
    }

    // .exonum.Config consensus = 1;


    pub fn get_consensus(&self) -> &super::blockchain::Config {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(ref v)) => v,
            _ => <super::blockchain::Config as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_consensus(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_consensus(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consensus(&mut self, v: super::blockchain::Config) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consensus(&mut self) -> &mut super::blockchain::Config {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(super::blockchain::Config::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consensus(&mut self) -> super::blockchain::Config {
        if self.has_consensus() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blockchain::Config::new()
        }
    }

    // .exonum.supervisor.ServiceConfig service = 2;


    pub fn get_service(&self) -> &ServiceConfig {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::service(ref v)) => v,
            _ => <ServiceConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ServiceConfig) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service(&mut self) -> &mut ServiceConfig {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::service(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::service(ServiceConfig::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service(&mut self) -> ServiceConfig {
        if self.has_service() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::service(v)) => v,
                _ => panic!(),
            }
        } else {
            ServiceConfig::new()
        }
    }

    // .exonum.supervisor.StartService start_service = 3;


    pub fn get_start_service(&self) -> &StartService {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(ref v)) => v,
            _ => <StartService as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_start_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_start_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_service(&mut self, v: StartService) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_service(&mut self) -> &mut StartService {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(StartService::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_service(&mut self) -> StartService {
        if self.has_start_service() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(v)) => v,
                _ => panic!(),
            }
        } else {
            StartService::new()
        }
    }

    // .exonum.supervisor.StopService stop_service = 4;


    pub fn get_stop_service(&self) -> &StopService {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(ref v)) => v,
            _ => <StopService as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_stop_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_stop_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_service(&mut self, v: StopService) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_service(&mut self) -> &mut StopService {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(StopService::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_service(&mut self) -> StopService {
        if self.has_stop_service() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(v)) => v,
                _ => panic!(),
            }
        } else {
            StopService::new()
        }
    }

    // .exonum.supervisor.ResumeService resume_service = 5;


    pub fn get_resume_service(&self) -> &ResumeService {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(ref v)) => v,
            _ => <ResumeService as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_resume_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_resume_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resume_service(&mut self, v: ResumeService) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resume_service(&mut self) -> &mut ResumeService {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(ResumeService::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resume_service(&mut self) -> ResumeService {
        if self.has_resume_service() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(v)) => v,
                _ => panic!(),
            }
        } else {
            ResumeService::new()
        }
    }

    // .exonum.supervisor.FreezeService freeze_service = 6;


    pub fn get_freeze_service(&self) -> &FreezeService {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(ref v)) => v,
            _ => <FreezeService as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_freeze_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_freeze_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_freeze_service(&mut self, v: FreezeService) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_freeze_service(&mut self) -> &mut FreezeService {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(FreezeService::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_freeze_service(&mut self) -> FreezeService {
        if self.has_freeze_service() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(v)) => v,
                _ => panic!(),
            }
        } else {
            FreezeService::new()
        }
    }

    // .exonum.supervisor.UnloadArtifact unload_artifact = 7;


    pub fn get_unload_artifact(&self) -> &UnloadArtifact {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(ref v)) => v,
            _ => <UnloadArtifact as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_unload_artifact(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_unload_artifact(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unload_artifact(&mut self, v: UnloadArtifact) {
        self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unload_artifact(&mut self) -> &mut UnloadArtifact {
        if let ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(UnloadArtifact::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unload_artifact(&mut self) -> UnloadArtifact {
        if self.has_unload_artifact() {
            match self.kind.take() {
                ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(v)) => v,
                _ => panic!(),
            }
        } else {
            UnloadArtifact::new()
        }
    }
}

impl ::protobuf::Message for ConfigChange {
    fn is_initialized(&self) -> bool {
        if let Some(ConfigChange_oneof_kind::consensus(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigChange_oneof_kind::service(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigChange_oneof_kind::start_service(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigChange_oneof_kind::stop_service(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigChange_oneof_kind::resume_service(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigChange_oneof_kind::freeze_service(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConfigChange_oneof_kind::unload_artifact(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::consensus(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::service(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::start_service(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::stop_service(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::resume_service(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::freeze_service(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ConfigChange_oneof_kind::unload_artifact(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &ConfigChange_oneof_kind::consensus(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigChange_oneof_kind::service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigChange_oneof_kind::start_service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigChange_oneof_kind::stop_service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigChange_oneof_kind::resume_service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigChange_oneof_kind::freeze_service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConfigChange_oneof_kind::unload_artifact(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &ConfigChange_oneof_kind::consensus(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigChange_oneof_kind::service(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigChange_oneof_kind::start_service(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigChange_oneof_kind::stop_service(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigChange_oneof_kind::resume_service(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigChange_oneof_kind::freeze_service(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConfigChange_oneof_kind::unload_artifact(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigChange {
        ConfigChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::blockchain::Config>(
                "consensus",
                ConfigChange::has_consensus,
                ConfigChange::get_consensus,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ServiceConfig>(
                "service",
                ConfigChange::has_service,
                ConfigChange::get_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartService>(
                "start_service",
                ConfigChange::has_start_service,
                ConfigChange::get_start_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StopService>(
                "stop_service",
                ConfigChange::has_stop_service,
                ConfigChange::get_stop_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResumeService>(
                "resume_service",
                ConfigChange::has_resume_service,
                ConfigChange::get_resume_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FreezeService>(
                "freeze_service",
                ConfigChange::has_freeze_service,
                ConfigChange::get_freeze_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, UnloadArtifact>(
                "unload_artifact",
                ConfigChange::has_unload_artifact,
                ConfigChange::get_unload_artifact,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigChange>(
                "ConfigChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigChange {
        static instance: ::protobuf::rt::LazyV2<ConfigChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigChange::new)
    }
}

impl ::protobuf::Clear for ConfigChange {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConfigPropose {
    // message fields
    pub actual_from: u64,
    pub changes: ::protobuf::RepeatedField<ConfigChange>,
    pub configuration_number: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigPropose {
    fn default() -> &'a ConfigPropose {
        <ConfigPropose as ::protobuf::Message>::default_instance()
    }
}

impl ConfigPropose {
    pub fn new() -> ConfigPropose {
        ::std::default::Default::default()
    }

    // uint64 actual_from = 1;


    pub fn get_actual_from(&self) -> u64 {
        self.actual_from
    }
    pub fn clear_actual_from(&mut self) {
        self.actual_from = 0;
    }

    // Param is passed by value, moved
    pub fn set_actual_from(&mut self, v: u64) {
        self.actual_from = v;
    }

    // repeated .exonum.supervisor.ConfigChange changes = 2;


    pub fn get_changes(&self) -> &[ConfigChange] {
        &self.changes
    }
    pub fn clear_changes(&mut self) {
        self.changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_changes(&mut self, v: ::protobuf::RepeatedField<ConfigChange>) {
        self.changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changes(&mut self) -> &mut ::protobuf::RepeatedField<ConfigChange> {
        &mut self.changes
    }

    // Take field
    pub fn take_changes(&mut self) -> ::protobuf::RepeatedField<ConfigChange> {
        ::std::mem::replace(&mut self.changes, ::protobuf::RepeatedField::new())
    }

    // uint64 configuration_number = 3;


    pub fn get_configuration_number(&self) -> u64 {
        self.configuration_number
    }
    pub fn clear_configuration_number(&mut self) {
        self.configuration_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_configuration_number(&mut self, v: u64) {
        self.configuration_number = v;
    }
}

impl ::protobuf::Message for ConfigPropose {
    fn is_initialized(&self) -> bool {
        for v in &self.changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.actual_from = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.changes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.configuration_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.actual_from != 0 {
            my_size += ::protobuf::rt::value_size(1, self.actual_from, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.configuration_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.configuration_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.actual_from != 0 {
            os.write_uint64(1, self.actual_from)?;
        }
        for v in &self.changes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.configuration_number != 0 {
            os.write_uint64(3, self.configuration_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigPropose {
        ConfigPropose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "actual_from",
                |m: &ConfigPropose| { &m.actual_from },
                |m: &mut ConfigPropose| { &mut m.actual_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigChange>>(
                "changes",
                |m: &ConfigPropose| { &m.changes },
                |m: &mut ConfigPropose| { &mut m.changes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "configuration_number",
                |m: &ConfigPropose| { &m.configuration_number },
                |m: &mut ConfigPropose| { &mut m.configuration_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigPropose>(
                "ConfigPropose",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigPropose {
        static instance: ::protobuf::rt::LazyV2<ConfigPropose> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigPropose::new)
    }
}

impl ::protobuf::Clear for ConfigPropose {
    fn clear(&mut self) {
        self.actual_from = 0;
        self.changes.clear();
        self.configuration_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigPropose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigPropose {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConfigVote {
    // message fields
    pub propose_hash: ::protobuf::SingularPtrField<super::types::Hash>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigVote {
    fn default() -> &'a ConfigVote {
        <ConfigVote as ::protobuf::Message>::default_instance()
    }
}

impl ConfigVote {
    pub fn new() -> ConfigVote {
        ::std::default::Default::default()
    }

    // .exonum.crypto.Hash propose_hash = 1;


    pub fn get_propose_hash(&self) -> &super::types::Hash {
        self.propose_hash.as_ref().unwrap_or_else(|| <super::types::Hash as ::protobuf::Message>::default_instance())
    }
    pub fn clear_propose_hash(&mut self) {
        self.propose_hash.clear();
    }

    pub fn has_propose_hash(&self) -> bool {
        self.propose_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propose_hash(&mut self, v: super::types::Hash) {
        self.propose_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propose_hash(&mut self) -> &mut super::types::Hash {
        if self.propose_hash.is_none() {
            self.propose_hash.set_default();
        }
        self.propose_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_propose_hash(&mut self) -> super::types::Hash {
        self.propose_hash.take().unwrap_or_else(|| super::types::Hash::new())
    }
}

impl ::protobuf::Message for ConfigVote {
    fn is_initialized(&self) -> bool {
        for v in &self.propose_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.propose_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.propose_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.propose_hash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigVote {
        ConfigVote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Hash>>(
                "propose_hash",
                |m: &ConfigVote| { &m.propose_hash },
                |m: &mut ConfigVote| { &mut m.propose_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigVote>(
                "ConfigVote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigVote {
        static instance: ::protobuf::rt::LazyV2<ConfigVote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigVote::new)
    }
}

impl ::protobuf::Clear for ConfigVote {
    fn clear(&mut self) {
        self.propose_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigVote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MigrationRequest {
    // message fields
    pub new_artifact: ::protobuf::SingularPtrField<super::base::ArtifactId>,
    pub service: ::std::string::String,
    pub deadline_height: u64,
    pub seed: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MigrationRequest {
    fn default() -> &'a MigrationRequest {
        <MigrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl MigrationRequest {
    pub fn new() -> MigrationRequest {
        ::std::default::Default::default()
    }

    // .exonum.runtime.ArtifactId new_artifact = 1;


    pub fn get_new_artifact(&self) -> &super::base::ArtifactId {
        self.new_artifact.as_ref().unwrap_or_else(|| <super::base::ArtifactId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_artifact(&mut self) {
        self.new_artifact.clear();
    }

    pub fn has_new_artifact(&self) -> bool {
        self.new_artifact.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_artifact(&mut self, v: super::base::ArtifactId) {
        self.new_artifact = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_artifact(&mut self) -> &mut super::base::ArtifactId {
        if self.new_artifact.is_none() {
            self.new_artifact.set_default();
        }
        self.new_artifact.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_artifact(&mut self) -> super::base::ArtifactId {
        self.new_artifact.take().unwrap_or_else(|| super::base::ArtifactId::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // uint64 deadline_height = 3;


    pub fn get_deadline_height(&self) -> u64 {
        self.deadline_height
    }
    pub fn clear_deadline_height(&mut self) {
        self.deadline_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadline_height(&mut self, v: u64) {
        self.deadline_height = v;
    }

    // uint64 seed = 4;


    pub fn get_seed(&self) -> u64 {
        self.seed
    }
    pub fn clear_seed(&mut self) {
        self.seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: u64) {
        self.seed = v;
    }
}

impl ::protobuf::Message for MigrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.new_artifact {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_artifact)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deadline_height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.new_artifact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if self.deadline_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.deadline_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seed != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seed, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.new_artifact.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if self.deadline_height != 0 {
            os.write_uint64(3, self.deadline_height)?;
        }
        if self.seed != 0 {
            os.write_uint64(4, self.seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MigrationRequest {
        MigrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::ArtifactId>>(
                "new_artifact",
                |m: &MigrationRequest| { &m.new_artifact },
                |m: &mut MigrationRequest| { &mut m.new_artifact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &MigrationRequest| { &m.service },
                |m: &mut MigrationRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "deadline_height",
                |m: &MigrationRequest| { &m.deadline_height },
                |m: &mut MigrationRequest| { &mut m.deadline_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seed",
                |m: &MigrationRequest| { &m.seed },
                |m: &mut MigrationRequest| { &mut m.seed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MigrationRequest>(
                "MigrationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MigrationRequest {
        static instance: ::protobuf::rt::LazyV2<MigrationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MigrationRequest::new)
    }
}

impl ::protobuf::Clear for MigrationRequest {
    fn clear(&mut self) {
        self.new_artifact.clear();
        self.service.clear();
        self.deadline_height = 0;
        self.seed = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MigrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MigrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MigrationResult {
    // message fields
    pub request: ::protobuf::SingularPtrField<MigrationRequest>,
    pub status: ::protobuf::SingularPtrField<super::lifecycle::MigrationStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MigrationResult {
    fn default() -> &'a MigrationResult {
        <MigrationResult as ::protobuf::Message>::default_instance()
    }
}

impl MigrationResult {
    pub fn new() -> MigrationResult {
        ::std::default::Default::default()
    }

    // .exonum.supervisor.MigrationRequest request = 1;


    pub fn get_request(&self) -> &MigrationRequest {
        self.request.as_ref().unwrap_or_else(|| <MigrationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: MigrationRequest) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut MigrationRequest {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> MigrationRequest {
        self.request.take().unwrap_or_else(|| MigrationRequest::new())
    }

    // .exonum.runtime.MigrationStatus status = 2;


    pub fn get_status(&self) -> &super::lifecycle::MigrationStatus {
        self.status.as_ref().unwrap_or_else(|| <super::lifecycle::MigrationStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::lifecycle::MigrationStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::lifecycle::MigrationStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::lifecycle::MigrationStatus {
        self.status.take().unwrap_or_else(|| super::lifecycle::MigrationStatus::new())
    }
}

impl ::protobuf::Message for MigrationResult {
    fn is_initialized(&self) -> bool {
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MigrationResult {
        MigrationResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MigrationRequest>>(
                "request",
                |m: &MigrationResult| { &m.request },
                |m: &mut MigrationResult| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::lifecycle::MigrationStatus>>(
                "status",
                |m: &MigrationResult| { &m.status },
                |m: &mut MigrationResult| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MigrationResult>(
                "MigrationResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MigrationResult {
        static instance: ::protobuf::rt::LazyV2<MigrationResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MigrationResult::new)
    }
}

impl ::protobuf::Clear for MigrationResult {
    fn clear(&mut self) {
        self.request.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MigrationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MigrationResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Config {
    // message fields
    pub mode: SupervisorMode,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // .exonum.supervisor.SupervisorMode mode = 1;


    pub fn get_mode(&self) -> SupervisorMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = SupervisorMode::SIMPLE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: SupervisorMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for Config {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != SupervisorMode::SIMPLE {
            my_size += ::protobuf::rt::enum_size(1, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mode != SupervisorMode::SIMPLE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config {
        Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupervisorMode>>(
                "mode",
                |m: &Config| { &m.mode },
                |m: &mut Config| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config>(
                "Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config {
        static instance: ::protobuf::rt::LazyV2<Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config::new)
    }
}

impl ::protobuf::Clear for Config {
    fn clear(&mut self) {
        self.mode = SupervisorMode::SIMPLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SupervisorMode {
    SIMPLE = 0,
    DECENTRALIZED = 1,
}

impl ::protobuf::ProtobufEnum for SupervisorMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupervisorMode> {
        match value {
            0 => ::std::option::Option::Some(SupervisorMode::SIMPLE),
            1 => ::std::option::Option::Some(SupervisorMode::DECENTRALIZED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupervisorMode] = &[
            SupervisorMode::SIMPLE,
            SupervisorMode::DECENTRALIZED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SupervisorMode>("SupervisorMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SupervisorMode {
}

impl ::std::default::Default for SupervisorMode {
    fn default() -> Self {
        SupervisorMode::SIMPLE
    }
}

impl ::protobuf::reflect::ProtobufValue for SupervisorMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rservice.proto\x12\x11exonum.supervisor\x1a\x19exonum/crypto/types.pr\
    oto\x1a\x17exonum/blockchain.proto\x1a\x19exonum/runtime/base.proto\x1a\
    \x1bexonum/runtime/errors.proto\x1a\x1eexonum/runtime/lifecycle.proto\
    \x1a\x1bgoogle/protobuf/empty.proto\"\x98\x01\n\rDeployRequest\x126\n\
    \x08artifact\x18\x01\x20\x01(\x0b2\x1a.exonum.runtime.ArtifactIdR\x08art\
    ifact\x12\x12\n\x04spec\x18\x02\x20\x01(\x0cR\x04spec\x12'\n\x0fdeadline\
    _height\x18\x03\x20\x01(\x04R\x0edeadlineHeight\x12\x12\n\x04seed\x18\
    \x04\x20\x01(\x04R\x04seed\"\x83\x01\n\x0cDeployResult\x12:\n\x07request\
    \x18\x01\x20\x01(\x0b2\x20.exonum.supervisor.DeployRequestR\x07request\
    \x127\n\x06result\x18\x02\x20\x01(\x0b2\x1f.exonum.runtime.ExecutionStat\
    usR\x06result\"r\n\x0cStartService\x126\n\x08artifact\x18\x01\x20\x01(\
    \x0b2\x1a.exonum.runtime.ArtifactIdR\x08artifact\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12\x16\n\x06config\x18\x03\x20\x01(\x0cR\x06co\
    nfig\".\n\x0bStopService\x12\x1f\n\x0binstance_id\x18\x01\x20\x01(\rR\ni\
    nstanceId\"0\n\rFreezeService\x12\x1f\n\x0binstance_id\x18\x01\x20\x01(\
    \rR\ninstanceId\"H\n\rServiceConfig\x12\x1f\n\x0binstance_id\x18\x01\x20\
    \x01(\rR\ninstanceId\x12\x16\n\x06params\x18\x02\x20\x01(\x0cR\x06params\
    \"H\n\rResumeService\x12\x1f\n\x0binstance_id\x18\x01\x20\x01(\rR\ninsta\
    nceId\x12\x16\n\x06params\x18\x03\x20\x01(\x0cR\x06params\"M\n\x0eUnload\
    Artifact\x12;\n\x0bartifact_id\x18\x01\x20\x01(\x0b2\x1a.exonum.runtime.\
    ArtifactIdR\nartifactId\"\xf5\x03\n\x0cConfigChange\x12.\n\tconsensus\
    \x18\x01\x20\x01(\x0b2\x0e.exonum.ConfigH\0R\tconsensus\x12<\n\x07servic\
    e\x18\x02\x20\x01(\x0b2\x20.exonum.supervisor.ServiceConfigH\0R\x07servi\
    ce\x12F\n\rstart_service\x18\x03\x20\x01(\x0b2\x1f.exonum.supervisor.Sta\
    rtServiceH\0R\x0cstartService\x12C\n\x0cstop_service\x18\x04\x20\x01(\
    \x0b2\x1e.exonum.supervisor.StopServiceH\0R\x0bstopService\x12I\n\x0eres\
    ume_service\x18\x05\x20\x01(\x0b2\x20.exonum.supervisor.ResumeServiceH\0\
    R\rresumeService\x12I\n\x0efreeze_service\x18\x06\x20\x01(\x0b2\x20.exon\
    um.supervisor.FreezeServiceH\0R\rfreezeService\x12L\n\x0funload_artifact\
    \x18\x07\x20\x01(\x0b2!.exonum.supervisor.UnloadArtifactH\0R\x0eunloadAr\
    tifactB\x06\n\x04kind\"\x9e\x01\n\rConfigPropose\x12\x1f\n\x0bactual_fro\
    m\x18\x01\x20\x01(\x04R\nactualFrom\x129\n\x07changes\x18\x02\x20\x03(\
    \x0b2\x1f.exonum.supervisor.ConfigChangeR\x07changes\x121\n\x14configura\
    tion_number\x18\x03\x20\x01(\x04R\x13configurationNumber\"D\n\nConfigVot\
    e\x126\n\x0cpropose_hash\x18\x01\x20\x01(\x0b2\x13.exonum.crypto.HashR\
    \x0bproposeHash\"\xa8\x01\n\x10MigrationRequest\x12=\n\x0cnew_artifact\
    \x18\x01\x20\x01(\x0b2\x1a.exonum.runtime.ArtifactIdR\x0bnewArtifact\x12\
    \x18\n\x07service\x18\x02\x20\x01(\tR\x07service\x12'\n\x0fdeadline_heig\
    ht\x18\x03\x20\x01(\x04R\x0edeadlineHeight\x12\x12\n\x04seed\x18\x04\x20\
    \x01(\x04R\x04seed\"\x89\x01\n\x0fMigrationResult\x12=\n\x07request\x18\
    \x01\x20\x01(\x0b2#.exonum.supervisor.MigrationRequestR\x07request\x127\
    \n\x06status\x18\x02\x20\x01(\x0b2\x1f.exonum.runtime.MigrationStatusR\
    \x06status\"?\n\x06Config\x125\n\x04mode\x18\x01\x20\x01(\x0e2!.exonum.s\
    upervisor.SupervisorModeR\x04mode*/\n\x0eSupervisorMode\x12\n\n\x06SIMPL\
    E\x10\0\x12\x11\n\rDECENTRALIZED\x10\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
